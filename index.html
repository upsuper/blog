<!DOCTYPE html>
<html lang="en">
<head>
        <title>鬼の领地</title>
        <meta charset="utf-8" />
        <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
                <link href="http://upsuper.github.com/blog/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="鬼の领地 Atom Feed" />
                
        <!--[if IE]>
                <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

        <!--[if lte IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie.css"/>
                <script src="./js/IE8.js" type="text/javascript"></script><![endif]-->

        <!--[if lt IE 7]>
                <link rel="stylesheet" type="text/css" media="all" href="./css/ie6.css"/><![endif]-->

</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="./">鬼の领地 </a></h1>
                <nav><ul>
                                                                                                    <li ><a href="./category/blog.html">Blog</a></li>
                                    <li ><a href="./category/research.html">Research</a></li>
                                    <li ><a href="./category/script.html">Script</a></li>
                                    <li ><a href="./category/study.html">Study</a></li>
                                    <li ><a href="./category/technique.html">Technique</a></li>
                                </ul></nav>
        </header><!-- /#banner -->
                
            

                            <aside id="featured" class="body">
                <article>
                    <h1 class="entry-title"><a href="./new-blog-in-github.html">在 GitHub 上建一个新的博客</a></h1> 
                    <footer class="post-info">
        <abbr class="published" title="2012-12-31T00:00:00">
                一 31 十二月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/blog.html">Blog</a>. </p>
<p>tags: <a href="./tag/blog.html">Blog</a><a href="./tag/github.html">GitHub</a></p>
</footer><!-- /.post-info --><p>一直想着将技术向博客迁移到 GitHub Pages 上，觉得这样大概可以使我显得更 Geek 一点吧？不过呢，因为一直以来各种事情很多，所以一直没有去做。（其实跟事情多也没什么关系吧，看看你自己都多久没写博客了……）最近看到之前买的虚拟空间快要到期了，因为不怎么打算继续续下去了，所以估量着把里面的东西迁移出来。另一方面，末日的2012过去了，新世界2013年到来了，顺便也就盘算着重新开始写博客？不过果然还是觉得有点麻烦呢……</p>
<p>既然是将这里定位于技术向的博客的话，自然除了关于这个博客本身的事情以外，其他都是技术讨论了。我其实也一直想把技术之外的一些内容单独放在一个博客里，只不过因为太懒了也是一直没去建的，估计在短时间内也不会去做吧，现在都没什么写东西的激情了呢。</p>
<p>这个博客的标题“鬼の领地”是延续自之前的博客的，它取自我中二的年代，正如我的常用 ID upsuper 一样。同时与之前我的每一个博客一样，我会把过去的内容挑选一些放入新的博客里面。另外原来参与 <a href="https://twitter.com/fanzeyi">@fanzeyi</a> 同学的 <a href="https://github.com/PyCodersCN">PyCodersCN</a> 项目的时候翻译过的一些文章也准备放进来。因为实在懒于写自己的东西（大多只是一些小东西，就不想单独写文章了），所以也考虑不定期的译一些自己觉得不错的文章放在这个博客里，就当练练中英文水平好了（其实是为了充数吧）。</p>
<p>关于这个博客本身，目前是准备使用 <a href="http://docs.getpelican.com/">Pelican</a> 来组织博客，使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> 来编写。很多人都推荐 <a href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>，但我始终是觉得那个东西比 Markdown 蛋疼得多。之后一段时间还有许许多多的工作要做呢这个博客，比如主题啦，之前文章的迁移，还有评论系统什么之类的。总之就这样吧，先用起来好了（虽然我觉得我也未必会坚持很久呢）。</p>                </article>
                            </aside><!-- /#featured -->
                            <section id="content" class="body">
                    <h1>Other articles</h1>
                    <hr />
                    <ol id="posts-list" class="hfeed">
                                                

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./implementing-a-generator-yield-in-a-python-c-extension.html" rel="bookmark"
                           title="Permalink to [翻译] 使用 Python C 扩展实现生成器/yield">[翻译] 使用 Python C 扩展实现生成器/yield</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-04-13T21:53:00">
                五 13 四月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/python.html">Python</a><a href="./tag/c.html">C</a></p>
</footer><!-- /.post-info -->                <p>原文：<a href="http://eli.thegreenplace.net/2012/04/05/implementing-a-generatoryield-in-a-python-c-extension/">Implementing a generator/yield in a Python C extension</a></p>
<p>在 Python 中，生成器 (generator) 是一个返回迭代器 (iterator) 对象的函数。虽然有很多方法来实现，不过最优雅和常用的形式是使用 <code>yield</code> 语句。</p>
<p>举例来说，这是一个简单的例子：</p>
<div class="codehilite"><pre><span class="k">def</span> <span class="nf">pyrevgen</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
        <span class="k">yield</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span>
</pre></div>


<p>这里的 <code>pyrevgen</code> 函数就是一个生成器。给定一个序列，它将会返回一个迭代器用以逆序输出这个串的元素并附上序号。比如说：</p>
<div class="codehilite"><pre><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">pyrevgen</span><span class="p">([</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b ...</span></pre></div>
                <a class="readmore" href="./implementing-a-generator-yield-in-a-python-c-extension.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./exploring-python-code-objects.html" rel="bookmark"
                           title="Permalink to [翻译] 探索 Python 代码对象">[翻译] 探索 Python 代码对象</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-03-31T05:50:00">
                六 31 三月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/study.html">Study</a>. </p>
<p>tags: <a href="./tag/python.html">Python</a></p>
</footer><!-- /.post-info -->                <p>原文：<a href="http://late.am/post/2012/03/26/exploring-python-code-objects">Exploring Python Code Objects</a></p>
<p>由于受到 <a href="http://www.dabeaz.com/">David Beazley</a> 在 <a href="https://us.pycon.org/2012/">PyCon</a> 上的 <a href="http://pyvideo.org/video/659/keynote-david-beazley">Keynote</a> 的启发，近来我四处学习与 Python 代码对象 (code object) 相关的内容。我并没有什么特别的利器，也没有专门的任务去解决 (至今为止？)，所以请将这篇文章看做一些也许有趣的记录和随笔 (如果没意思的话，抱歉)。</p>
<p><em>免责声明：</em>这篇文章是关于 CPython 2.7 的，虽然其中的大部分对于其他的 CPython 版本应该也是正确的 (包括 3.x)。但我不保证它在 PyPy、Jython、IronPython 等实现上是正确和适用的。</p>
<h2>第0步：是什么？</h2>
<p>所以首先，代码对象是什么呢？许多人 (特别是仇视 Python 的人 ...</p>
                <a class="readmore" href="./exploring-python-code-objects.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./python-internals-how-callables-work.html" rel="bookmark"
                           title="Permalink to [翻译] Python 内部：可调用对象是如何工作的">[翻译] Python 内部：可调用对象是如何工作的</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-03-25T09:10:00">
                日 25 三月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/study.html">Study</a>. </p>
<p>tags: <a href="./tag/python.html">Python</a><a href="./tag/c.html">C</a></p>
</footer><!-- /.post-info -->                <p>原文：<a href="http://eli.thegreenplace.net/2012/03/23/python-internals-how-callables-work/">Python internals: how callables work</a></p>
<p><em>【这篇文章所描述的 Python 版本是 3.x，更确切地说，是 CPython 3.3 alpha。】</em></p>
<p>在 Python 中，可调用对象 (callable) 的概念是十分基本的。当我们说什么东西是“可调用的”，马上可以联想到的显而易见的答案便是函数。无论是用户定义的函数 (你所编写的) 还是内置的函数 (经常是在 CPython 解析器内由 C 实现的)，他们总是用来被调用的，不是么？</p>
<p>当然，还有方法也可以调用，但他们仅仅是被限制在对象中的特殊函数而已，没什么有趣的地方。还有什么可以被调用呢？你可能知道，也可能不知道，只要一个对象所属的类定义了 <code>__call__</code> 魔术方法，它也是可以被调用的。所以对象可以像函数那样使用。再深入思考一点，类也是可以被调用的 ...</p>
                <a class="readmore" href="./python-internals-how-callables-work.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./using-fuzzy-matching-to-search-by-sound-with-python.html" rel="bookmark"
                           title="Permalink to [翻译] 在 Python 中使用模糊匹配根据发音搜索">[翻译] 在 Python 中使用模糊匹配根据发音搜索</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-03-10T16:39:00">
                六 10 三月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/python.html">Python</a><a href="./tag/sound.html">Sound</a></p>
</footer><!-- /.post-info -->                <p>原文：<a href="http://www.informit.com/articles/article.aspx?p=1848528">Using Fuzzy Matching to Search by Sound with Python</a></p>
<p><strong>当你编写代码搜索数据库时，你不能总是依赖于相信所有的数据项都有正确的拼写。DreamHost 的开发者以及《Python 标准库编程范例》(<em><a href="http://www.informit.com/store/product.aspx?isbn=0321767349">The Python Standard Library by Example</a></em>) 的作者 Doug Hellmann 在这篇文章中回顾了一些根据目标的发音，而不是准确的拼写，进行数据库搜索的方法。</strong></p>
<p>在数据库中搜索人名是一项独特的挑战。对于不同来源和不同年代的数据，你不但不能指望其中名字的拼写是正确的，甚至相同的名字如果多次出现时，它们的拼写都不一定一样。而储存的数据和搜索项之间也有可能因为个人喜好、文化差异、<a href="http://zh.wikipedia.org/wiki/%E5%90%8C%E9%9F%B3%E7%95%B0%E7%BE%A9%E8%AA%9E">同音词</a>、拼写错误、文盲或仅仅因为在某些时期根本没有标准拼法而出现差异。这些问题在历史学家、谱系学家和其他研究者的手写的文本记录中尤为常见。</p>
<p>一个常用的解决这样的字符串搜索问题的方法是寻找与搜索目标相近的值。但是，使用传统的<a href="http://en.wikipedia.org/wiki/Approximate_string_matching">模糊匹配算法</a>计算两个任意字符串之间的相似度，代价是很大的，同时它也不适合用于搜索大规模数据集。一个更好的解决方案是为数据库里的每一项预先计算一个哈希值，有一些专门的哈希算法正是为此设计的。这些语音算法 ...</p>
                <a class="readmore" href="./using-fuzzy-matching-to-search-by-sound-with-python.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./static-modification-of-python-with-python-the-ast-module.html" rel="bookmark"
                           title="Permalink to [翻译] AST 模块：用 Python 修改 Python 代码">[翻译] AST 模块：用 Python 修改 Python 代码</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2012-03-03T16:47:00">
                六 03 三月 2012
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/python.html">Python</a></p>
</footer><!-- /.post-info -->                <p>原文：<a href="http://blueprintforge.com/blog/2012/02/27/static-modification-of-python-with-python-the-ast-module/">Static Modification of Python With Python: The AST Module</a></p>
<p>修改代码在有时会变的十分有用，比如在进行测试和分析的时候。在这篇文章中，我们将看到如何使用 <code>ast</code> 模块对 Python 代码进行修改，同时还将看到一些使用了这个技术的工具。</p>
<h2>CPython 的编译过程</h2>
<div style="float: left; margin-right: 20px;"><img src="./static/images/pep339.png" /></div>

<p>在开始之前，我们应该先看看 CPython 的编译过程，这个过程在 <a href="http://www.python.org/dev/peps/pep-0339/">PEP 339</a> 中有详细的描述。</p>
<p>当然，在读这篇文章的时候，你并不需要对这个步骤有很深入的理解，不过这可以帮助你对整个过程有一个大体的了解。</p>
<p>首先，编译器会根据源代码生成一棵语法分析树 (Parse Tree)，随后，再根据语法分析树建立抽象语法树 (AST, Abstract Syntax Tree)。从 AST 中可以生成出控制流图 (CFG, Control Flow Graph ...</p>
                <a class="readmore" href="./static-modification-of-python-with-python-the-ast-module.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./dynamic-modify-cpu-number.html" rel="bookmark"
                           title="Permalink to 动态切换 Linux 使用的 CPU 数量">动态切换 Linux 使用的 CPU 数量</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2011-10-19T14:04:00">
                三 19 十月 2011
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/script.html">Script</a>. </p>
<p>tags: <a href="./tag/linux.html">Linux</a></p>
</footer><!-- /.post-info -->                <p>由于要测试一些代码，其运行结果会受到多核并行的影响，所以希望能够调整使用的 CPU 数量。网络上之前看到的方法是在内核的启动参数上添加一个 <code>maxcpus</code>，但是如果这样的话每切换一次都要重启一次，是在太麻烦了。想想 Linux 应该是很强大的，所以可以动态修改 CPU 数量才对。</p>
<p>无意中看到 Linux 代码的 <code>Documentation</code> 文件夹下有个文件叫做 <code>cpu-hotplug.txt</code>，于是就看了一下，发现可以在 <code>/sys/devices/system/cpu</code> 看到代表各 CPU 的文件夹按照 <code>cpuX</code> 的命名方式，如 <code>cpu0</code>、<code>cpu1</code>、<code>cpu2</code> 等。这些文件夹里面有一个 <code>online</code> 文件，如果其值为0则禁用该 CPU，如果为1则启用该 CPU。注意，这里需要 <code>root</code> 权限哦。</p>
<p>因为我只要在单核和多核之间切换 ...</p>
                <a class="readmore" href="./dynamic-modify-cpu-number.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./setup-lxr.html" rel="bookmark"
                           title="Permalink to 安装配置 LXR">安装配置 LXR</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2011-10-03T15:07:00">
                一 03 十月 2011
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/linux.html">Linux</a></p>
</footer><!-- /.post-info -->                <p>专业课学习操作系统，满心欢喜地以为可以是 Linux 代码导读，结果选用了一本八十年代的教材，介绍 UNIX v6 的。于是自己从图书馆借来了内核开发的入门读物《Linux 内核设计与实现》。既然是介绍内核的书，自然少不了代码，但是书中又不可能将每个提到的代码的相关信息全部写出来，这时就得自己去查看代码。查看代码的话，虽然 Linux 的代码可以很容易地得到，但那来看终归有些麻烦，各种调用需要查找半天。于是想起了很有名的一个网站 <a href="http://lxr.linux.no">LXR</a>，Linux 交叉引用。这个网站好是好，就是网络原因速度太慢，于是就想自己装一个。</p>
<p>先说一句，下面的安装环境都是64位 Gentoo。</p>
<p>最开始找到了 <a href="http://sourceforge.net/projects/lxr/">LXR Cross Referencer</a> 这个项目，一看最后更新时间还挺新，看起来是一直都还在维护的。然后在 Gentoo 的网站上查到 LXR 是可以直接用 portage 安装的，于是安装，安装相关的包，最后放弃了。出于什么原因我也不记得了 ...</p>
                <a class="readmore" href="./setup-lxr.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./gmail-super-sub-mailbox.html" rel="bookmark"
                           title="Permalink to Gmail 的超级子邮箱功能">Gmail 的超级子邮箱功能</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2011-03-06T22:11:00">
                日 06 三月 2011
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/gmail.html">Gmail</a></p>
</footer><!-- /.post-info -->                <p>如果你也用 Gmail，他可以让你轻易拥有无限多的子邮箱，发给这些邮箱也就等于发给你的邮箱。这有什么意义呢？很简单，你可以在每个地方注册的时候都使用不同的邮箱，这样当你收到垃圾邮件广告邮件，你就可以知道是从哪里来的了~再结合 Gmail 强大的过滤器，你也可以针对性的进行屏蔽~</p>
<p>Gmail 事实上支持两种方式来扩张你的邮箱，第一种是在你的用户名后面加上“+”和任意字符串，比如我的邮箱 <code>quanxunzhen@gmail.com</code>（我这邮箱无所谓了已经嗯），如果我想要识别不同的网站，比如豆瓣，我可以直接在豆瓣的注册邮箱里填写 <code>quanxunzhen+douban@gmail.com</code>，所有验证邮件都可以发给我，我如果不想申请一个新邮箱却想注册个豆瓣小号，也可以再写 <code>quanxunzhen+douban2@gmail.com</code>。</p>
<p>当然，支持上面的方式固然是最好的，但遗憾的是很多网站并不支持带加号的邮箱，那就要稍稍麻烦点了。</p>
<p>根据 <a href="http://fanfou.com/fanzeyi">@fanzeyi</a> 的说法，Gmail 的邮箱是自动忽略点，也就是“.”的，也就是说对于我上面的邮箱，如果写为 <code>quan ...</code></p>
                <a class="readmore" href="./gmail-super-sub-mailbox.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            

                 
                        <li><article class="hentry">    
                <header>
                    <h1><a href="./advanced-prompt-of-bash.html" rel="bookmark"
                           title="Permalink to 增强版的 Bash 提示符">增强版的 Bash 提示符</a></h1>
                </header>
                
                <div class="entry-content">
                <footer class="post-info">
        <abbr class="published" title="2011-02-28T14:40:00">
                一 28 二月 2011
        </abbr>

                <address class="vcard author">
                By <a class="url fn" href="./author/xidorn-quan.html">Xidorn Quan</a>
        </address>
        <p>In <a href="./category/technique.html">Technique</a>. </p>
<p>tags: <a href="./tag/bash.html">bash</a></p>
</footer><!-- /.post-info -->                <p>上周六参加了好久没有参加的的 SHLUG 月聚，恰逢 <a href="http://imtx.me/">TualatriX</a> 也带团来上海。自由讨论的时候，我看到 TualatriX 的终端十分色彩斑斓，便询问，他给我们展示了他的 bash 的两个特色功能：1、当上一条命令返回结果不为0时显示返回值并高亮显示提示符；2、自动检测git分支。他说这个在他的博客上都可以找到，今天想起来去找了一下，发现了这篇：<a href="http://imtx.me/archives/1298.html">史上最强的PS1 | I’m TualatriX</a>，感觉满强大的。</p>
<p>不过，说实话，我觉的这个还不够完美，原因有二：一是我发觉高亮显示的时候那个配色相当不怎么样，二是我本来就讨厌提示符太长，这样一下就更长了……于是我就想起 ghosTM 的 zsh 里面有一些信息是放在右边的，我想把返回值也扔右边去，并且是右边上移一行。此外，由于很少使用 <code>git</code>，所以检测 <code>git</code> 分支的功能也就不需要了~</p>
<p>先放一个最终效果图：
<img alt="Bash 提示符的最终效果图" src="./static/images/advanced-prompt-of-bash-01.png" /></p>
<p>然后直接写出了我的新的 <code>PS1</code>：</p>
<div class="codehilite"><pre><span class="nv">PS1 ...</span></pre></div>
                <a class="readmore" href="./advanced-prompt-of-bash.html">read more</a>
                                </div><!-- /.entry-content -->
            </article></li>
                            </ol><!-- /#posts-list -->
                            <p class="paginator">
        Page 1 / 3
            <a href="./index2.html">&raquo;</a>
    </p>
                        </section><!-- /#content -->
                    <section id="extras" class="body">
                        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>