Title: Gmail 的超级子邮箱功能
Date: 2011-03-06 22:11
Tags: Gmail
Category: Technique
Slug: gmail-super-sub-mailbox
Author: Xidorn Quan

如果你也用 Gmail，他可以让你轻易拥有无限多的子邮箱，发给这些邮箱也就等于发给你的邮箱。这有什么意义呢？很简单，你可以在每个地方注册的时候都使用不同的邮箱，这样当你收到垃圾邮件广告邮件，你就可以知道是从哪里来的了~再结合 Gmail 强大的过滤器，你也可以针对性的进行屏蔽~

Gmail 事实上支持两种方式来扩张你的邮箱，第一种是在你的用户名后面加上“+”和任意字符串，比如我的邮箱 `quanxunzhen@gmail.com`（我这邮箱无所谓了已经嗯），如果我想要识别不同的网站，比如豆瓣，我可以直接在豆瓣的注册邮箱里填写 `quanxunzhen+douban@gmail.com`，所有验证邮件都可以发给我，我如果不想申请一个新邮箱却想注册个豆瓣小号，也可以再写 `quanxunzhen+douban2@gmail.com`。

当然，支持上面的方式固然是最好的，但遗憾的是很多网站并不支持带加号的邮箱，那就要稍稍麻烦点了。

根据 [@fanzeyi](http://fanfou.com/fanzeyi) 的说法，Gmail 的邮箱是自动忽略点，也就是“.”的，也就是说对于我上面的邮箱，如果写为 `quan.xun.zhen@gmail.com`，或者 `..quanxunzhen..@gmail.com`，我照样可以收到。而且这样写法的邮箱通常不会被屏蔽，因为点毕竟是邮箱必备的部分。

但是这样加点有一个问题，就是我们无法像第一种方式那样很容易的区分来源，因此我们不得不进行某种编码。

## 顺序编码

第一种编码的思想大体上是按照传统的数据库中记录的自增 ID，转为二进制表示，具体的说就是，比如我这个邮箱有11位，那么我们可以以中间有打点或者没有打点作为二进制位中的0和1，比如就可以如下表示：

    0 quanxunzhen
    1 quanxunzhen.
    2 quanxunzhe.n
    3 quanxunzhe.n.
    29 quanxun.z.h.en.

这样……

但是这样总编码数也就 2<sup>len(email)+1</sup> 种，对于我邮箱这么长，也仅仅4096种，总归有点少。（其实也不少了吧喂……）

于是我们考虑一下扩张的方法。

其实扩张很简单，因为任意两个字母之间可以插入的点是任意多的，我们可以利用这一点按照一定的协议来编码，比如我们规定第一个字符之前如果有 n 个点，则之后每个字母之间最多可以有 n+1 个点，这样当第一个字符前有 n 个点时，最大可以编码 (n+2)<sup>len(email)</sup> 种，如果规定这里每次数字都是从上一次结束的数字开始，编码就不会重复了，而且可编码的范围大大增加，却又没有太多的增加点的数量。对于我的邮箱来说，前面一个点也没有时可以有 2048 种，有一个点时可以有 177147+2048 种，有两个点时可以有 4194304+177147+2048 种，我相信是用不完的了……

事实上基于此还可以延伸出各种各样的编码方式~

## 字符编码

不过上面的方法总归不那么直观，而且如果想追踪来源，还要建表，表的同步还是个问题，所以这个问题还是挺大的……于是我有了第二种想法，可以把注册地的名字嵌入到里面~

最基本的想法是根据字母序，比如在 Arch 论坛注册我们可以把 Arch 变成数字串 0 17 2 7，插入进去变成：

    qu.................a..n.......xunzhen

不过我们可以明显的感觉到很蛋疼……Arch 还算好的，如果是新浪（Sina -> 18 8 13 0）或者淫淫网（Renren -> 17 4 13 17 4 13）就更蛋疼了……

但是我们感觉到不是这样的，我们完全不需要那么多字母其实也可以认出他们来不是么？比如淫淫网我们可以用 rr，或者原名校内的 xn，新浪就 sn 什么的，这样需要的字母就少了，我们就可以利用变换进制的优势了~26对于二进制位需要5位，对于3进制恰好只要3位，当然算起来如果你的邮箱够长肯定还是用二进制可以增加的更短一些，对于我来说就是如此，比如上面的就可以这样变化了：

    rr -> 17 17 -> 10001 10001 -> q.uanx.u.nzhe.n
    xn -> 23 13 -> 10111 01101 -> q.ua.n.x.un.z.he.n
    sn -> 18 13 -> 10010 01101 -> q.uan.xun.z.he.n

如果三进制的话，我的 upsuper 也可以容下了：

    rr -> 17 17 -> 122 122 -> u.p..s..u.p..e..r
    xn -> 23 13 -> 212 111 -> u..p.s..u.p.e.r
    sn -> 18 13 -> 200 111 -> u..psu.p.e.r

看过去好多了~

我们还可以发挥其它的想象力，比如找寻标识中的字母频率然后构建一个霍夫曼编码树什么的~

我能想到的暂时只有这么多了，各位还有什么更有意思的想法么？
