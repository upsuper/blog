<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>鬼の领地</title><link href="http://upsuper.github.com/blog/" rel="alternate"></link><link href="http://upsuper.github.com/blog/feeds/Study.atom.xml" rel="self"></link><id>http://upsuper.github.com/blog/</id><updated>2009-07-28T23:20:00+08:00</updated><entry><title>Linux 死机了该怎么办？</title><link href="http://upsuper.github.com/blog/what-to-do-if-linux-crash.html" rel="alternate"></link><updated>2009-07-28T23:20:00+08:00</updated><author><name>Xidorn Quan</name></author><id>tag:upsuper.github.com/blog,2009-07-28:what-to-do-if-linux-crash.html</id><summary type="html">&lt;p&gt;Linux 会死机么？我可以很肯定地说，会！如何？很简单，&lt;a href="http://zh.wikipedia.org/zh/Fork%E7%82%B8%E5%BC%B9"&gt;fork 炸弹&lt;/a&gt;就可以~要让 Linux 死机很容易，但难的是在死机以后如何安全的让他摆脱死机状态。&lt;/p&gt;
&lt;p&gt;Linux 死机有很多种情况，最常见的是系统负载过高导致的。如上次介绍的 fork 炸弹就是这个原理，此外还可以运行内存耗用极大的程序（如虚拟机），也会迅速提升系统负载。由于系统负载过高导致的卡死，一定是解决的越快越好！此时必须记住的是，不能再试图依赖任何图形界面的东西，如 Gnome 的系统监视器（这是我从 Windows 遗留下来的愚昧习惯……），这只会继续加重这种卡死的局面。那怎么办？&lt;/p&gt;
&lt;p&gt;不要怕，Linux 最初就是不需要图形界面的，因为有一个很强大的文字界面。按 Ctrl-Alt-F1（F1-F6 一般来说都可以），然后等一会儿，就会切换到 tty，也就是所谓的文字界面。这个时候需要用用户名密码登入。注意，可能键盘输入的速度比较慢，不过应该还是可以忍受的。下面在提示符后面输入 top 回车，这时会看到一张动态的表，上面列出了耗用资源最多的进程。观察它刷新一两次，按q退出，然后输入 kill ，其中的 PID 你可以在 top 里面看到。这个时候应该会快了不少，如果你发现没有成功结束掉，就再输入 kill -KILL ，这次基本上就没问题了。&lt;/p&gt;
&lt;p&gt;除了上面这种情况外，一些底层软件的 bug 也可能导致一些奇怪的死机问题。我某位同学近日就因为莫名其妙的死机强制重启把 ext4 的分区给伤了。（最后是 sysreccd 修复了，貌似是分区表部分损坏）据其说，死机是键鼠均无反应。一般来说，系统负载高导致的死机，在可怕键盘也会有反应，有人说如果死机到键盘无响应“负载都无限大了”，亦有人说这可能是 X Server 与驱动配合有问题导致的。不过我们考虑一下遇到这种情况怎么办？&lt;/p&gt;
&lt;p&gt;OK，这是今天才学到的方法，叫做 reisub，这个方法可以在各种情况下安全地重启计算机。大家在键盘上找，可以找到一个叫做“Sys Rq”的键，在台机的键盘上通常与 Prt Sc 共键，在笔记本可能在其他位置，如 Delete。以台机为例，要使用这种方法需要按住 Alt-Print(Sys Rq)，然后依次按下 reisub 这几个键，按完 b 系统就会重启。&lt;/p&gt;
&lt;p&gt;下面解释一下这个方法：其实 Sys Rq 是一种叫做系统请求的东西，按住 Alt-Print 的时候就相当于按住了 Sys Rq 键，这个时候输入的一切都会直接由 Linux 内核来处理，它可以进行许多低级操作。这个时候 reisub 中的每一个字母都是一个独立操作，他们分别表示：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;unRaw&lt;/span&gt;      将键盘控制从 &lt;span class="n"&gt;X&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt; 那里抢回来
 &lt;span class="n"&gt;tErminate&lt;/span&gt; 给所有进程发送 &lt;span class="n"&gt;SIGTERM&lt;/span&gt; 信号，让他们自己解决善后
 &lt;span class="n"&gt;kIll&lt;/span&gt;      给所有进程发送 &lt;span class="n"&gt;SIGKILL&lt;/span&gt; 信号，强制他们马上关闭
  &lt;span class="n"&gt;Sync&lt;/span&gt;     将所有数据同步至磁盘
  &lt;span class="n"&gt;Unmount&lt;/span&gt;  将所有分区挂载为只读模式
&lt;span class="n"&gt;reBoot&lt;/span&gt;     重启
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这6个字母的顺序是不可以记错的。那怎么记呢？这里提供一个个人认为比较好的方法：单词 busier（busy 的比较级，更忙）倒过来就是了。&lt;/p&gt;
&lt;p&gt;基本上就这样了，Linux 的死机本来就不多见，现在见了也可以安全解决，多好~&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Magic_SysRq_key"&gt;Magic SysRq key – Wikipedia, the free encyclopedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category></entry><entry><title>探秘 Linux 权限控制</title><link href="http://upsuper.github.com/blog/access-control-of-linux.html" rel="alternate"></link><updated>2009-07-06T16:08:00+08:00</updated><author><name>Xidorn Quan</name></author><id>tag:upsuper.github.com/blog,2009-07-06:access-control-of-linux.html</id><summary type="html">&lt;p&gt;众所周知，Linux 的权限控制虽然很简单，但却十分严格和有效的。（和 Windows 复杂却没用的权限控制形成鲜明对比……）由于最近编写测评机，希望利用 Linux 的高安全性做运行级恶意代码防护，因此就顺带地研究了一下 Linux 的权限控制。经过这次探秘，我对 Linux 的权限有了更新的认识，确实是一个很强大的东西啊！&lt;/p&gt;
&lt;p&gt;由于本人的能力有限，文章中的不足和谬误也请大家多多指教！&lt;/p&gt;
&lt;p&gt;我想，稍微接触过一段时间 Linux 的人都会对 Linux 的权限有些许了解，其中最重要的莫过于——很多命令需要加 sudo 才能运行，而且我们也知道，sudo 几乎无所不能——不能删的就 sudo rm、不能复制 sudo cp、不能移动 sudo mv……（目前我仅发现在部分虚拟文件系统中 sudo 也没有权限做这些事情……）那么，sudo 究竟是何方神圣，Linux 又是如何确定这些权限的呢？&lt;/p&gt;
&lt;p&gt;说到 Linux 下的权限，一定要先说的是 Linux 下文件权限的控制。在 Linux 下，每个文件都有“所有者”和“所在组”这两个基本属性，而各种权限也是根据所有者、所在组和其他人划分的。每个文件的权限，最简单的情况下可以表示为一个3位八进制数，每一位八进制数表示一系列人的权限，如八进制数751就标示所有者有7的权限，所在组的其他人有5的权限，而既不是所有者也不在所在组的人只有1的权限。至于一位的八进制数表示的意义，我们应该将其进一步转换为3位二进制数，如7对应111，5对应101，1对应001。在这个二进制数上最高位如果为1则表示有读权限，第二位表示写权限，而最后一位表示执行权限。（说到这里我就想再插一句了，Linux 的文件是什么类型或可不可以执行，几乎完全不是根据扩展名，只有有执行权限的文件才能执行，而文件类型也是根据 MIME Type 来决定的。）&lt;/p&gt;
&lt;p&gt;由于 Linux 里面大量的东西都可以转化为文件操作，因此这一简洁明了的设计解决了大多数权限控制的问题。不过文件归文件，那文件夹呢？文件夹应该说也是一类特殊的文件，因此也有权限控制。可对于文件夹，什么样叫“可读”，什么样叫“可写”？最奇怪的是，“可执行”？对于文件夹来说，可读就是可以列举文件列表，也就是 Linux 下的 ls 命令可以列出东西；可写就是可以在文件夹中创建文件（或许有人会问，为什么不是文件夹中文件可写？想一想~）；可执行是比较奇怪的……就是将这个文件夹当作当前文件夹的权限，在 Linux 命令中表现为 cd 是否可以使用。&lt;/p&gt;
&lt;p&gt;好了，说完文件们，再来看看进程们。&lt;/p&gt;
&lt;p&gt;进程的权限控制就更简单了，说白了就一句话：一个进程不能控制与其不是同一个用户下运行的进程，除非被控制的是它的子进程。事实上，一个进程有至少两个 UID 和 GID，它们分别是 EUID、RUID 和 EGID、RGID，其中，E 表示 effective，即所有权限控制参考的是 EUID 和 EGID，进程创建的文件的所有者和所在组也是 EUID 和 EGID 表示的用户和组。那么有人就问，R- 的那两个又是拿来干什么的呢？打酱油？非也，R 表示 real，即运行者的信息。其实一个进程可以改变自己这些 UID 和 GID，而 E- 可以修改为的值为其本身和对应的 R- 的值。不过一个程序在加载的时候 E- 和 R- 的值似乎都根据运行者的信息设置了相同的值，看起来好像没什么用，是吗？我们这里暂且不管他。&lt;/p&gt;
&lt;p&gt;下面我们深入一步，看看进程调度中的 nice 值和进程的资源限制。不知道大家有没有用系统监视器调整过进程的 nice 值，nice 值是 Linux 核心调度进程的一个参考值，nice 值越高表示这个进程越不重要，优先级越低，越可以慢慢来；nice 值越低表示这个进程越重要，越要快些做。调过 nice 的人就知道，将可以控制的某个进程的 nice 值调高（优先级降低）是随便做的，但要把一个进程的 nice 值调低（提高优先级）却要输入密码（进入 root）。做过一些 Linux 相关的编程的人也应该知道，调紧一个可控进程的资源限制是可以随意调的，但调宽松也要由 root 来进行。&lt;/p&gt;
&lt;p&gt;啊，root 出现了！root 是什么？root 对于 Linux 来说就是神。为什么这么说？你上面看到的所有权限控制，在 root 面前都是没用的，root 在 Linux 里可以为所欲为。是的，root 是一个完全不受权限限制的用户，这就是它可怕的地方。比如，我们在前面看到进程只能将 EUID 调整为 EUID 或 RUID，但如果 EUID 为 0（即为 root），这个进程将可以把 EUID 和 RUID 调整为任意值；同样的，这个进程将可以把 EGID 和 RGID 调整为任意值。&lt;/p&gt;
&lt;p&gt;我们知道 Linux 内核加载的时候开始执行的进程 init 是以 root 运行的，而后 init 加载各个启动脚本，把各项服务封入单独的用户运作，最后根据登入信息加载用户进程。这整个过程中，只有由上而下，由 root 到普通用户的过程。理由就是 root 可以任意调整 E- 和 R-。不过如果仅是这样，这个系统估计什么也干不了……&lt;/p&gt;
&lt;p&gt;我在原来的一篇日志中提到过 Linux 创建子进程和运行程序的方法——fork 和 exec* 函数：fork 运行成功返回两次，一次在生成的子进程中返回0，另一次在调用的父进程中返回子进程的 pid。此时，子进程迅速继承了父进程的所有权限、变量等等等等。（Linux 的子进程采用 copy-on-write 技术分享父进程的内存）而我们前面又知道，一个进程只能让自己从 root 到普通用户，优先级从高到低，资源限制从宽到严，就像水只能从高流向低一样。但，人是往高出走的，有时我们需要 root 的权限，问：路在何方？&lt;/p&gt;
&lt;p&gt;就在这时候，sudo 出现了！sudo 在 Linux 中可为无人不知无人不晓。对于 sudo 来说，只要你这个用户在 sudoer 的列表中，输入你的密码就可以让你成为 root 了，或者你输入其他用户的密码可以让你使用其他用户。可是，我们前面刚刚说过，进程只能让自己从 root 变成普通用户，那这 sudo 又是哪冒出来的呢？&lt;/p&gt;
&lt;p&gt;这又要回到文件权限设置了。其实，文件权限实际上有4位八进制数。我们原来说的是3位，那还有一位是什么呢？那一位对应的3个二进制位又是三个开关，分别标示 SUID、SGID 和粘着位。SUID 是什么？它表示 saved set-user-ID，设置了它的程序在运行时有了新的选择——程序所有者的权限！也就是说，EUID 的取值在 EUID、RUID 之外多了一个选择——SUID。事实上，有设置 SUID 的程序在执行时都会自动将 EUID 设置为 SUID，这时 EUID 和 RUID 就不再是同一个值了，我们前面又知道，只要 EUID 为0这个程序就无敌了。这个过程在 fork 中无法完成，我猜想是在 exec* 函数的调用过程中进行的。我们看到，sudo 这个程序的所有者是 root，而又有设置 SUID，这表示，我们一运行 sudo，它就以 root 在运行了！很神奇不是么？通过 SUID 这种特别的机制，原来许多不可能的事成为了可能。SGID 表示的含义亦是类似的；而至于粘着位表示这个文件对于任何人都可写，但只有所有者能删除。&lt;/p&gt;
&lt;p&gt;到这里，我把 Linux 基本的权限控制机制都说了一番。当然，为了更精确地进行权限控制，Linux 内核还引入了 Linux 安全模块，并可以加入 SELinux 和 AppArmor 等增强的安全机制，这让 Linux 更加安全和坚不可摧。（Windows 的权限控制在这些面前简直就是幼稚园小孩在大学教授面前……）这些我就不细致展开了，更多的信息网上很容易找到。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://linuxtoy.org/docs/guide/ch17s08.html"&gt;权限管理 – 开源世界旅行手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cndw.com/tech/server/2006040430540.asp"&gt;Solaris下究竟如何使用setuid/seteuid/setreuid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://lxr.linux.no/"&gt;the Linux Cross Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tech.ccidnet.com/art/741/20090623/1806969_1.html"&gt;Linux系统进程的几个用户ID及其转换方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://idcnews.net/html/edu/20070101/291393.html"&gt;用户信息 /etc/passwd，getuid(), getpwuid()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://hi.baidu.com/phps/blog/item/7e3ba44410cf9580b3b7dc81.html"&gt;C语言系统资源控制（getrlimit &amp;amp;&amp;amp; setrlimit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bytes.com/groups/python/36126-permission-problem-os-setuid"&gt;permission problem with os.setuid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Linux"></category><category term="Security"></category></entry><entry><title>探索 Python 的变量、类型和引用</title><link href="http://upsuper.github.com/blog/python-variable-type-and-reference.html" rel="alternate"></link><updated>2009-06-25T22:23:00+08:00</updated><author><name>Xidorn Quan</name></author><id>tag:upsuper.github.com/blog,2009-06-25:python-variable-type-and-reference.html</id><summary type="html">&lt;p&gt;我一开始为 Python 的强大和简洁所震撼，看了些 Python 的教程，学了不少东西。前面那些探索就以后再写吧……今天先讲讲今天知道的东西。&lt;/p&gt;
&lt;p&gt;在探索到 Python 函数的参数传递的时候，我不禁赞叹 Python 灵活的参数设计，但慢慢的，开始迷惑与传递参数的修改和返回。&lt;/p&gt;
&lt;p&gt;众所周知，在 C++ 中传递参数分为传值和传引用两种，但 Python 没有，那到底传进去的东西，修改一下，能不能传出来呢？这是一个很奇怪和让人费解的问题，不是么？在查阅了一些资料后，对 Python 关于变量、类型和引用的一些基本方式有了一些了解，进而基于这种理解并结合实验，了解了参数传递的奥妙。&lt;/p&gt;
&lt;p&gt;Python 的变量是没有类型的，这与以往看到的大部分语言都不一样。但 Python 却是区分类型的，那类型在哪里呢？事实是，类型是跟着内存中的对象走的。Python 的所有变量其实都是指向内存中的对象的一个指针，所有的变量都是！此外，对象还分两类：一类是可修改的，一类是不可修改的。&lt;/p&gt;
&lt;p&gt;现在，我插入在此先说说函数参数的问题，我们有下面一个实验：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;0
&lt;span class="p"&gt;[&lt;/span&gt;0&lt;span class="p"&gt;,&lt;/span&gt; 2&lt;span class="p"&gt;,&lt;/span&gt; 3&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看看结果会不会很惊异？第一个看起来像传值，第二个看起来却像传引用？看到这里你是不是觉得 Python 是一种莫名其妙的语言？其实当时我也有这种想法……但 Python 果然没哟让我失望，它如同 UNIX 一样，一开始设计得就如此优美。继续往下看~&lt;/p&gt;
&lt;p&gt;不可修改的对象是我们最常用和最熟悉，几乎在任何一个语言中都能看到的——整数、实数、字符串和元组。有人说，怎么不可变啊？我随便给他们赋值！是的，在 Python 里几乎一切都是可以改变的，甚至有人说“如果你愿意，None 的值也是可以变的”（当然我不知道怎么变……）。但是如果注意观察，会发现所谓的改变其实是——&lt;strong&gt;扔了旧的建个新的！&lt;/strong&gt;验证这个的实验很简单：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似的实验想怎么做怎么做，只要那两个是不可变对象，你就一定会发现 id 变了！为什么？因为对象不可变。那什么可变？变量的引用是可变的！&lt;/p&gt;
&lt;p&gt;好，那么自然剩下的就是可变的对象了，上面的实验亦可以很容易的证实字典、列表、集合和类实例等对象是可变的。那么，这意味着什么呢？&lt;/p&gt;
&lt;p&gt;下面，我们回到函数传值的问题。我们知道了可变对象和不可变对象的区别，不是吗？对于可变对象，对于对象的操作不会重建对象，而对于不可变对象，每一次操作就重建新的对象。那么函数参数到底是个什么东西呢？&lt;strong&gt;其实说白了也简单，就是把参数里传入的东西对相应对象的引用依次赋给对应的内部变量&lt;/strong&gt;（有点晕吗？）。看看第一个实验，有没有明白些什么？其实都是将一个指向对象的引用传个一个名为“参数”的本地变量，所以 func1 中给 a 的是一个值为 0 的整数对象的引用，但我们知道，整数对象是不可变的，所以当 func1 对 a 进行修改的时候，实际上是修改本地变量 a 的引用到一个新的值为 1 的整数对象的引用。那么很显然，func2 修改的是一个可变的对象，也就是说即使 func2 修改了 a，本地变量 a 和全局变量 t2 指向的还是同一个对象，虽然他们不是同一个变量！这样一切情况都明了了，不是么？不明了的话再看看下面这个实验：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出一定是：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="p"&gt;[[&lt;/span&gt;0&lt;span class="p"&gt;,&lt;/span&gt; 2&lt;span class="p"&gt;,&lt;/span&gt; 3&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;4&lt;span class="p"&gt;,&lt;/span&gt; 5&lt;span class="p"&gt;,&lt;/span&gt; 6&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实原理和参数的传递是一致的。&lt;/p&gt;
&lt;p&gt;我们下面来看看全局变量和本地变量的问题。如果一个函数里面使用了一个变量，那么 Python 会先看看有没有对应的本地变量，如果没有找到，但找到一个全局变量，那么 Python 会&lt;strong&gt;把那个全局变量的引用赋给一个新的本地变量&lt;/strong&gt;。所以，现在在函数里的那个变量和全局变量其实不是同一个变量，他们只不过暂时有了相同的引用。这样其实可以看作 Python 为你做了隐式的参数传递。因此我们发现，他和参数一样，传值传引用表面上看过去漂移不定。那么如何修改一个指向不可变全局变量的值呢？靠返回值显然不那么优美。好在 Python 像 PHP 那样提供了一个叫 global 的语法，被 global 的变量&lt;strong&gt;使得本地变量成为相应全局变量的一个别名&lt;/strong&gt;，也就是说这个语句使他们成为同一个变量，这一点很重要！&lt;/p&gt;
&lt;p&gt;现在看到了 Python 优美的设计。那下面的问题是，如果我们一定要复制一个可变对象的副本怎么办？简单的等号赋值显然被证明无效了。Python 也提供了方法——copy 模块。copy 模块是每一个 Python 都有的，专门用于生成可变对象的副本。copy 模块中有两个函数：copy.copy 和 copy.deepcopy。其中 copy 叫做潜复制，它仅仅复制了第一你给它的东西，下面的不管了。而 deepcopy 叫做深复制，它将所有能复制的都复制了。这样说比较抽象，我们来看下面实验：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deepcopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;[[1, 2, 3], [4, 5, 10], 15]&lt;/span&gt;
&lt;span class="k"&gt;[[1, 2, 3], [4, 5, 10], 15]&lt;/span&gt;
&lt;span class="k"&gt;[[1, 2, 3], [4, 5, 10]]&lt;/span&gt;
&lt;span class="k"&gt;[[1, 2, 3], [4, 5, 6]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我想，效果不言而喻了。&lt;/p&gt;
&lt;p&gt;此外，我还看到一个叫做弱引用 (weakref) 的模块，暂时不知道是干嘛的……下次研究了再说……&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/winterTTr/archive/2008/06/27/2590741.aspx"&gt;Python的函数参数传递：传值？引用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.jb51.net/article/15714.htm"&gt;Python 拷贝对象（深拷贝deepcopy与浅拷贝copy）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/sislcb/archive/2008/09/05/1284828.html"&gt;Python 学习笔记 – 8.引用(Reference)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="Python"></category></entry></feed>